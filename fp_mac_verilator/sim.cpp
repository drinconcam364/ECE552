#include "Vfdpmac.h"     // Generated by Verilator
#include "verilated.h"

#include <iostream>
#include <cstdint>
#include <cstring>
#include <cmath>

vluint64_t sim_time = 0;

// One clock cycle: low->high
void tick(Vfdpmac *dut) {
    dut->clk = 0;
    dut->eval();
    sim_time++;

    dut->clk = 1;
    dut->eval();
    sim_time++;
}

static float fp_to_float(uint16_t fp) {
    // Convert binary float to decimal 
    uint16_t s = (fp >> 15) & 0x1; // keep top bit
    uint16_t e = (fp >> 10) & 0x1F; // next 5 bits
    uint16_t f = fp & 0x3FF; // bottom 10 bits
    
    float sign = s ? -1.0f : 1.0f;

    if (e == 0) {
        if (f == 0) return sign * 0.0f; // zero
        return sign * (f / 1024.0f) * powf(2, -14);
    }

    if (e == 31) {
        return sign * INFINITY;
    }

    return sign * (1.0f + f / 1024.0f) * powf(2, (int)e - 15);
}

uint32_t golden_mac(uint32_t rs1, uint32_t rs2, uint32_t acc) {
    uint16_t a0 = rs1 & 0xFFFF;
    uint16_t a1 = (rs1 >> 16) & 0xFFFF;

    uint16_t b0 = rs2 & 0xFFFF;
    uint16_t b1 = (rs2 >> 16) & 0xFFFF;

    float fa0 = fp_to_float(a0);
    float fa1 = fp_to_float(a1);
    float fb0 = fp_to_float(b0);
    float fb1 = fp_to_float(b1);

    float facc;
    std::memcpy(&facc, &acc, sizeof(facc));

    float res = facc + fa0 * fb0 + fa1 * fb1;
    uint32_t bres;
    std::memcpy(&bres, &res, sizeof(bres));
    return bres;


}

// Run one test vector
bool run_test(Vfdpmac *dut, uint32_t rs1, uint32_t rs2, uint32_t acc) {
    // Apply inputs
    dut->rs1   = rs1;
    dut->rs2   = rs2;
    dut->acc   = acc;
    dut->start = 1;

    tick(dut);          // latch start
    dut->start = 0;

    // Wait for valid
    const int max_cycles = 50;
    int waited = 0;

    while (!dut->valid && waited < max_cycles) {
        tick(dut);
        waited++;
    }

    if (!dut->valid) {
        std::cerr << "[FAIL] Timeout waiting for valid\n";
        return false;
    }

    uint32_t rtl  = dut->result;
    uint32_t gold = golden_mac(rs1, rs2, acc);
    bool pass = (rtl == gold);

    std::cout << "rs1=0x" << std::hex << rs1
              << " rs2=0x" << rs2
              << " acc=0x" << acc
              << " -> result=0x" << rtl
              << " (golden=0x" << gold << ") "
              << (pass ? "[PASS]" : "[FAIL]") << std::dec << "\n";

    return pass;
}

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);

    auto *dut = new Vfdpmac;

    // Reset
    dut->clk   = 0;
    dut->rst_n = 0;
    dut->start = 0;
    dut->rs1   = 0;
    dut->rs2   = 0;
    dut->acc   = 0;

    for (int i = 0; i < 4; i++) tick(dut); // a few reset cycles
    dut->rst_n = 1;
    tick(dut);

    bool ok = true;

    // Example dummy tests – you’ll replace these with real FP16-packed values
    ok &= run_test(dut, 0x3C003C00, 0x40004000, 0x00000000);
    ok &= run_test(dut, 0x3C003C00, 0x3C003C00, 0x3F800000);

    if (ok) std::cout << "\nAll tests PASSED\n";
    else    std::cout << "\nSome tests FAILED\n";

    dut->final();
    delete dut;
    return ok ? 0 : 1;
}
